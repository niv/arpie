= What's this?

Arpie is a end-to-end framework for sending synchronous message-and-answer
pairs, and serves as the basis for a RPC framework, handling a variety of protocols,
including a generic Marshal proof of concept; writing your own Protocol is quite simple.

* It uses ruby threads on the server side, one per connection.
* The client is single-threaded.

== Source Code

Source code is in git[http://git.swordcoast.net/?p=lib/ruby/arpie.git;a=summary].

You can contact me via email at elven@swordcoast.net.

arpie is available on the rubygems gem server - just do <tt>gem1.8 install arpie</tt>
to get the newest version.


== Simple, contrived example: A string reverse server

  require 'rubygems'
  require 'arpie'
  require 'socket'

  server = TCPServer.new(51210)

  e = Arpie::Server.new(Arpie::MarshalProtocol.new)

  e.handle do |server, ep, msg|
    ep.write_message msg.reverse
  end

  e.accept do
    server.accept
  end

  c = Arpie::Client.new(Arpie::MarshalProtocol.new)
  c.connect do |transport|
    TCPSocket.new("127.0.0.1", 51210)
  end

  c.write_message "hi"
  puts c.read_message
  # => "ih"

== Advanced, but still simple example: Using Proxy to access remote objects

  require 'rubygems'
  require 'arpie'
  require 'socket'

  class MyHandler
    def reverse str
      str.reverse
    end
  end

  server = TCPServer.new(51210)

  e = Arpie::ProxyServer.new(Arpie::MarshalProtocol.new)

  e.handle MyHandler.new

  e.accept do
    server.accept
  end

  p = Arpie::ProxyClient.new(Arpie::MarshalProtocol.new)
  p.connect do |transport|
    TCPSocket.new("127.0.0.1", 51210)
  end

  puts p.reverse "hi"
  # => "ih"


== Replay protection

It can happen that a Client loses connection to a Server.
In that case, the Transport tries transparently reconnecting by simply
invoking the block again that was given to Client#connect.
See the Client accessors for modifying this behaviour.

It is assumed that each call, that is being placed, is atomic - eg, no
connection losses in between message send and receive; lost messages
will be retransmitted. Some Protocol classes provide support for replay
protection through in-band UUIDs; though it is not a requirement to implement it.
If a UUID is provided in the data stream, the Protocol will not call
the handler again for retransmissions, but instead reply with the old,
already evaluated value.

Not all protocols support UUIDs; those who do not offer no replay protection,
and special care has to be taken elsewhere.

All object-encoding protocols support UUIDs, including YAML and Marshal.
XMLRPC does not.

== Benchmarks

There is a benchmark script included in the git repository (and in the gem
under tools/). A sample output follows; your milage may vary.

        user     system      total        real

  native DRb
     1  0.000000   0.000000   0.000000 (  0.000167)
  1000  0.120000   0.010000   0.130000 (  0.121834)

  ruby xmlrpc/server - too slow to benchmark

  Arpie: proxied MarshalProtocol
     1  0.000000   0.000000   0.000000 (  0.000617)
  1000  0.100000   0.020000   0.120000 (  0.114573)
